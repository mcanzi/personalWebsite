---
title: "Introduction to data visualisation with R and ggplot"
author: "Massimiliano Canzi"
date: 2021-01-21
tags: ["ggplot", "R", "data"]
draft: false
---



<div id="setup-packages" class="section level1">
<h1>Setup &amp; packages</h1>
<div id="packages" class="section level2">
<h2>Packages</h2>
<p>The focus of this introductory, <em>code-along</em> workshop is to get you acquainted with the basic syntax of the <code>ggplot()</code> package, as well as to provide sample code that you can later on expand for the analysis of your own data.</p>
<p>The <code>tidyverse</code> packages include <code>ggplot2</code>, the package focus of this workshop, as well as other useful additions. The packages of the tidyverse <em>universe</em> have been created to work seamlessly together, often times replacing basic R functions with more elegant, efficient solutions.</p>
<pre class="r"><code>#install.packages(&quot;tidyverse&quot;)
library(tidyverse)</code></pre>
<pre><code>## ── Attaching packages ─────────────────</code></pre>
<pre><code>## ✓ ggplot2 3.3.2     ✓ purrr   0.3.4
## ✓ tibble  3.0.3     ✓ dplyr   1.0.2
## ✓ tidyr   1.1.2     ✓ stringr 1.4.0
## ✓ readr   1.3.1     ✓ forcats 0.5.0</code></pre>
<pre><code>## ── Conflicts ──────────────────────────
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>library(datasets)</code></pre>
</div>
</div>
<div id="the-data" class="section level1">
<h1>The data</h1>
<p>Today we will be working with different types of (linguistic) data to showcase common types of plots and ways to visualise your findings. The aim is to get you acquainted with different issues arising from different types of plots, as well as to provide you with a comprehensive range of examples that you can use and expand on for your own work.</p>
<p>We will be mainly working with three types of data:</p>
<ul>
<li>Event-related potential, <strong>ERP</strong> data</li>
<li><strong>Vowel</strong> information (formants, duration, etc)</li>
<li>Non linguistic information (the <strong>iris</strong> dataset)</li>
</ul>
<div id="erp-dataset" class="section level2">
<h2>ERP dataset</h2>
<p>Let us <code>read_csv()</code> the <strong>ERP</strong> dataset provided to you for this course. It is always a good idea to inspect your dataset with the <code>head()</code> command. The dataset contains ERP data from 3 experiments, namely the <code>"ATT"</code>, <code>"BSL"</code> and <code>"PRS"</code> levels of the <code>block</code> variable. Today we are focusing on data from one experiment only, the <code>"ATT"</code> experiment.</p>
<p>To do this, we “pipe” (i.e. the <code>%&gt;%</code> operator) into the <code>filter()</code> function, which substitutes the core R <code>subset()</code> function, to only accept any observation where <code>block == "ATT"</code>.</p>
<p>If you are unsure of what argument a function requires, you can always use the <code>?</code> command followed by the function name (e.g. <code>?filter()</code>)</p>
<p>The <code>%&gt;%</code> operator should be read as “then” (e.g. read this file to the variable ERP and <strong>THEN</strong> only save observations where block equals “ATT”). <code>%&gt;%</code> allows you to combine multiple operations and it is a very elegant solution.</p>
<p>The <code>%&gt;%</code> operator should be read as “then” (e.g. read this file to the variable ERP and <strong>THEN</strong> only save observations where block equals “ATT”). <code>%&gt;%</code> allows you to combine multiple operations and it is a very elegant solution.</p>
<pre class="r"><code>head(ERP)</code></pre>
<pre><code>## # A tibble: 6 x 12
##   subject block condition electrode  time amplitude.mean chanNo theta radius
##     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     202 ATT   control   Fp1        -100           0.04      1 -17.9  0.515
## 2     202 ATT   control   Fp1         -98           0.04      1 -17.9  0.515
## 3     202 ATT   control   Fp1         -96           0.01      1 -17.9  0.515
## 4     202 ATT   control   Fp1         -94          -0.04      1 -17.9  0.515
## 5     202 ATT   control   Fp1         -92          -0.1       1 -17.9  0.515
## 6     202 ATT   control   Fp1         -90          -0.16      1 -17.9  0.515
## # … with 3 more variables: radianTheta &lt;dbl&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;</code></pre>
</div>
<div id="att-data" class="section level2">
<h2>“ATT” data</h2>
<p>The core of experiment <strong>“ATT”</strong> consisted of participants listening to a sequence of three syllables, presented auditorily and separated by a short pause (e.g. levels <code>"first_syllable"</code>, <code>"second_syllable"</code> and <code>"third_syllable"</code> of the <code>condition</code> variable). Once all three syllables had been presented, subjects were instructed that they had four seconds to mentally concatenate the three syllables in the sequence to form a (nonce) word. Participants were also instructed not to alter the order in which the syllables were presented. Following the four-second pause in which participants completed the behavioural task, subjects would hear a nonce word that either <strong>matched</strong> (i.e. level <code>"control"</code> of the <code>condition</code> variable) the nonce word made up of the three syllables (66% of the time) or a <strong>mismatch</strong> (i.e. level <code>"target"</code> of the <code>condition</code> variable) nonce word that presented a different first syllable (33% of the time). Both the match and mismatch stimuli would present the same trisyllabic structure and the only differences would be the choice of CV combination in the first syllable.</p>
<p>For each <code>subject</code> (e.g. <code>"201"</code>, <code>"202"</code>, etc.) at each <code>electrode</code> (e.g. <code>"FCz"</code>, <code>"Fz"</code>, etc.) and for each experimental condition of the five summarised above, the <strong>DV</strong>, <code>amplitude_mean</code>, is average measurements (of every time that particular stimulus was presented to a given subject) taken with a sampling rate of 512 Hz between a ‘time’ of <code>-100</code> and <code>700</code> after the presentation of the stimulus.</p>
<p>For example..</p>
<pre class="r"><code>ERP_single &lt;- ERP %&gt;%
  filter(subject == 202) %&gt;%
  filter(condition == &quot;control&quot;) %&gt;%
  filter(electrode == &quot;Fp1&quot;)

plot &lt;- plot(ERP_single$time, 
             ERP_single$amplitude.mean,
             xlim = c(-100, 500),
             ylim = c(-5, 5),
             type = &quot;l&quot;) </code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>The plot above is an average of the ERP responses of subject <code>202</code>, at electrode site <code>Fp1</code> (pre-frontal) to the presentation of <code>control</code> (i.e. matching) stimuli. The plot is extremely basic. While it seem to work and could potentially clean up nicely once axes lables and a title are added, things start to get complicated once we want to plot grand averages (averages of all subjects at one electrode site for one condition) or when we want to arrange multiple panes together to showcase responses at different electrode sites, etc.</p>
</div>
</div>
<div id="ggplot2" class="section level1">
<h1>ggplot2</h1>
<div id="line-plots" class="section level2">
<h2>Line plots</h2>
<div id="aesthetics" class="section level3">
<h3>Aesthetics</h3>
<p><strong>ggplot2</strong> makes it much easier, and it looks pretty, too! A <code>ggplot</code> object usually contains two parts. The first part, often referred to as the <strong>aesthestics</strong> or <code>aes()</code> is where the data are mapped onto the axes of the plot, as well as where information regarding color coding and the data set are included.</p>
<pre class="r"><code>my_aes &lt;- ggplot(data = ERP_single, # what dataset we use 
                   aes(x = time, # what variable should  be mapped onto x
                       y = amplitude.mean)) # what ... onto y
my_aes</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>However, if you run the block of code above, nothing happens and the plot is not populated. Every <code>ggplot</code> object requires the following instructions, added to the core object with a <code>+</code>. Required info often only includes the plot geometry (e.g. scatterplot, lineplot, violin plot). Many more non mandatory instructions can be added on, such as labels and axis information, legend, titles, colour scales and so on.</p>
<p>Let’s start with something simple.</p>
</div>
<div id="function-geom_line" class="section level3">
<h3>Function geom_line()</h3>
<pre class="r"><code>my_first_ggplot &lt;- ggplot(data = ERP_single,
                   aes(x = time, 
                       y = amplitude.mean)) +
  geom_line() # line plot geometry added to the aesthetics of the ggplot object

my_first_ggplot</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>This is a very basic line plot we created by adding the <code>geom_line()</code> geometry. As you can see, we used default options for all of the parameters of the <code>geom_line()</code> function. If you want to explore all the different options of this particular geometry, as well aesthetic options, you can read more at <code>?geom_line()</code>. Below is an example where a few of the <code>geom_line()</code> parameters are modified. For example, with</p>
<p><code>geom_line(linetype = 3, size = 0.5)</code></p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p><code>geom_line(linetype = 4, size = 1.2, colour = "red")</code></p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
</div>
<div id="comparing-multiple-conditions" class="section level3">
<h3>Comparing multiple conditions</h3>
<p>In the previous plots, we displayed the average ERP responses of subject <code>202</code> to <code>"control"</code> stimuli at electrode site <code>Fp1</code>. But what if we wanted to visually compare the ERP components in response to <code>"control"</code> and <code>"target"</code> stimuli at electrode site <code>FC3</code> for example? First of all, let’s subset our <code>ERP</code> dataset appropriately.</p>
<pre class="r"><code>ERP_comparison &lt;- ERP %&gt;%
  filter(subject == 202) %&gt;%
  filter(electrode == &quot;FC3&quot;) %&gt;%
  filter(condition == &quot;control&quot; | condition == &quot;target&quot;)

head(ERP_comparison)</code></pre>
<pre><code>## # A tibble: 6 x 12
##   subject block condition electrode  time amplitude.mean chanNo theta radius
##     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     202 ATT   control   FC3        -100           0.08     10 -62.4  0.288
## 2     202 ATT   control   FC3         -98           0.06     10 -62.4  0.288
## 3     202 ATT   control   FC3         -96           0.04     10 -62.4  0.288
## 4     202 ATT   control   FC3         -94           0.01     10 -62.4  0.288
## 5     202 ATT   control   FC3         -92          -0.02     10 -62.4  0.288
## 6     202 ATT   control   FC3         -90          -0.02     10 -62.4  0.288
## # … with 3 more variables: radianTheta &lt;dbl&gt;, x &lt;dbl&gt;, y &lt;dbl&gt;</code></pre>
<p>The <code>|</code> operator in the final line of the block is read as “or”.
Now that our <code>ERP_comparison</code> dataset contains both <code>"control"</code> and <code>"target"</code> data, we can use <code>ggplot()</code> to visually compare. In order to do so, we want to add a parameter in the <code>aes()</code> portion of the code. In particular, we want to specify that the colour of the line should change depending on the experimental <code>condition</code>. We do so by saying <code>colour = condition</code>.</p>
<pre class="r"><code>plot4 &lt;- ggplot(data = ERP_comparison,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition)) +
  geom_line()

plot4</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>We are using ERP data in this particular tutorial because it’s what I’m most comfortable with given my background. However, these line plots are used for the visualisation of many types of data in linguistic, such as pitch contours, acoustic spectra, ultrasound tongue contours, frequency of word use over time, diphtong measurements, etc.</p>
<p>Because many paper publications are printed in black and white, it is often wise not to have <code>colour</code> as the only difference between the two lines, we can add <code>linetype = condition</code> in the <code>aes()</code> portion of the plot. If you have multiple comparisons, you can mix and match and have <code>colour = x</code> and <code>linetype = y</code>. You can also still specify other <strong>unspecified</strong> paramenters directly in the <code>geom_line()</code> function directly, such as the <code>size</code> of the line and <code>alpha</code>, its transparency. When you add a colour / linetype <strong>by</strong> variable option, a legend is automatically generated.</p>
<pre class="r"><code>plot4 &lt;- ggplot(data = ERP_comparison,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition, 
                       linetype = condition)) +
  geom_line(size = 0.9, alpha = 0.9)

plot4</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="manual-scales" class="section level3">
<h3>Manual scales</h3>
<p>The colours and linetype options are chosen automatically by <code>ggplot()</code> but we can specify the options we prefer by creating <strong>manual scales</strong>. For instance, our figure uses two colours, so we can create a vector <code>col_options</code> that contains the names of two colours of our choice. Let’s do that.</p>
<p>You can find a list of all the colour names you can use in this handy .pdf <a href="https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf">here</a> on page <strong>3</strong>.</p>
<pre class="r"><code>col_options &lt;- c(&quot;hotpink2&quot;, &quot;deepskyblue4&quot;)</code></pre>
<p>Now, we’re going to tell <code>ggplot()</code> that it should use our colour scale when looking for colour options, we do that by adding the <code>scale_colour_manual</code> line.</p>
<pre class="r"><code>plot5 &lt;- ggplot(data = ERP_comparison,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition, 
                       linetype = condition)) +
  geom_line(size = 0.9, alpha = 0.9) +
  scale_colour_manual(values = col_options)

plot5</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p><strong>Note:</strong> in the <code>ggplot2</code> environment, the keyword <code>colour</code> is used for the colours of objects such as lines and points. However, if you wanted to colour the inside of a box (in a box plot) you must use <code>fill</code> in the aesthetics (e.g. <code>fill = condition</code>) and you will specify your scale with <code>scale_fill_manual</code>. If you use <code>colour</code> and <code>scale_colour_manual</code> on a boxplot it will work. However, it will affect the colour of the borders of the box, rather the colour inside the box.</p>
<p><strong>Note2:</strong> Both AmE and BrE spelling of the word colo(u)r is accepted in a ggplot envionment so <code>scale_colour_manual()</code> and <code>scale_color_manual()</code> will both work.</p>
</div>
<div id="odds-and-ends" class="section level3">
<h3>Odds and ends</h3>
<p>Our plot is looking much nicer already, but let’s add some odds and ends to make it look even better.</p>
<div id="title-and-labels" class="section level4">
<h4>Title and labels</h4>
<p>We can add a title to our plot by adding the line</p>
<p><code>ggtitle("our title")</code></p>
<p>We can add axis labels with the lines <code>xlab("x label")</code> and <code>ylab("y label")</code>.</p>
<pre class="r"><code>plot6 &lt;- ggplot(data = ERP_comparison,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition, 
                       linetype = condition)) +
  geom_line(size = 0.9, alpha = 0.9) +
  scale_colour_manual(values = col_options) +
  ggtitle(&quot;Averaged amplitude response across trials 
          for subject 202 at electrode FC3&quot;) +
  xlab(&quot;Time (in ms)&quot;) +
  ylab(expression(paste(&quot;Amplitude (in &quot;, mu, &quot;V)&quot;)))

plot6</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
<div id="themes" class="section level4">
<h4>Themes</h4>
<p><code>ggplot()</code> comes standard with multiple themes, depending on the look you prefer. The one I use the most if <code>theme_minimal()</code> but others often used include <code>theme_classic()</code> and <code>theme_bw()</code> if you want to see what your plot would look like in black and white. You change the theme simply by adding one of the above lines to your plot.</p>
<p><code>+ theme_minimal()</code></p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
<div id="final-touches" class="section level4">
<h4>Final touches</h4>
<p>We can add a vertical line at <code>time = 0</code> to indicate when the stimulus is presented. This is done by adding the following line:</p>
<p><code>+ geom_vline(xintercept = 0, linetype = 2)</code></p>
<p>This is often customary in ERP data visualisation.</p>
<p>Finally, we can make the title a little bit smaller to fit the remainder of the text in the plot, by adding the following line</p>
<p><code>+ theme(plot.title = element_text(size = 11, face = "bold")))</code></p>
<pre class="r"><code>plot8 &lt;- ggplot(data = ERP_comparison,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition, 
                       linetype = condition)) +
  geom_line(size = 0.9, alpha = 0.9) +
  scale_colour_manual(values = col_options) +
  ggtitle(&quot;Averaged amplitude response across trials 
          for subject 202 at electrode FC3&quot;) +
  xlab(&quot;Time (in ms)&quot;) +
  ylab(expression(paste(&quot;Amplitude (in &quot;, mu, &quot;V)&quot;))) +
  geom_vline(xintercept = 0, linetype = 2) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = &quot;bold&quot;))

plot8</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>Awesome, now we can finally save the plot to disk.</p>
</div>
<div id="saving-the-plot" class="section level4">
<h4>Saving the plot</h4>
<p>To save the plot to disk, we use the <code>ggsave()</code> function.</p>
<pre class="r"><code>ggsave(filename = &quot;./ERP_plot.png&quot;, plot = plot8, height = 8, width = 12)</code></pre>
<p>With <code>ggsave()</code>, you can specify different <code>height</code> and <code>width</code> parameters — as well as the <code>resolution</code> parameter — depending on preferred image ratios and requirements.</p>
</div>
</div>
<div id="multiple-panels" class="section level3">
<h3>Multiple panels</h3>
<p>Previously, we have created an ERP line plot that shows the average response of subject <code>202</code> to the presentation of <code>"control"</code> and <code>"target"</code> stimuli at electrode <code>FC3</code>. What if we wanted to visually compare it to the same pot for subjects <code>206</code>, <code>209</code> and <code>210</code>? Certainly, we could simply create four different plots and arrange them together. That could be done using the function <code>ggarrange()</code>. However, it’s a lot of unnecessary code. Luckily there’s a solution and it’s called <code>facet_wrap()</code>. Let’s see how to use <code>facet_wrap()</code> in a <code>ggplot</code> environment to create multiple panels in the same plot. First of all, let’s subset our dataset.</p>
<pre class="r"><code>ERP_foursubj &lt;- ERP %&gt;%
  filter(condition == &quot;control&quot; | condition == &quot;target&quot;) %&gt;%
  filter(subject == 202 | subject == 206 |
         subject == 210 | subject == 209) %&gt;%
  filter(electrode == &quot;FC3&quot;)</code></pre>
<p>Now, let’s use <code>plot8</code> as a template and ladd the <code>facet_wrap</code> line to create multiple panels. More specifically we want four panels, one per subject.</p>
<pre class="r"><code>plot9 &lt;- ggplot(data = ERP_foursubj,
                   aes(x = time, 
                       y = amplitude.mean,
                       colour = condition, 
                       linetype = condition)) +
  geom_line(size = 0.9, alpha = 0.9) +
  scale_colour_manual(values = col_options) +
  ggtitle(&quot;Averaged amplitude response across trials 
          for subject 202, 206, 209 and 210 at electrode FC3&quot;) +
  xlab(&quot;Time (in ms)&quot;) +
  ylab(expression(paste(&quot;Amplitude (in &quot;, mu, &quot;V)&quot;))) +
  geom_vline(xintercept = 0, linetype = 2) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = &quot;bold&quot;)) + 
  facet_wrap(vars(subject))
plot9</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>As you can see, all four plots share the same <code>scale</code>, <code>legend,</code> <code>ggtitle</code> and axis labels.</p>
<p>Similarly to what we have done above, we could have, for instance, displayed the ERP response of subject <code>202</code> to the presentation of <code>"control"</code> and <code>"target"</code> stimuli across a variety of electrode sites. Let’s do that.</p>
<pre class="r"><code>ERP_fourelec &lt;- ERP %&gt;% 
  filter(condition == &quot;control&quot; | condition == &quot;target&quot;) %&gt;%
  filter(electrode == &quot;F3&quot; | electrode == &quot;FC3&quot; |
           electrode == &quot;C3&quot; | electrode == &quot;P3&quot;) %&gt;%
  filter(subject == 202) </code></pre>
<p>And now the plot. In this particular instance we want to use <code>vars(electrode)</code> instead of <code>vars(subject)</code> inside the <code>facet_wrap()</code> function.</p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>The advantage of <code>ggarrange()</code> over <code>facet_grid()</code> is, however, the <code>ggarrange()</code> allows you to combine together multiple <code>ggplot</code> objects that can be of an geometry combination. For instance, you could have in one single plot the combination of a box plot, a line plot and a histogram.</p>
</div>
</div>
<div id="box-violin-plots" class="section level2">
<h2>Box / Violin plots</h2>
<p>For the purpose of practicing boxplots and violin plots, we will be using the <em>very famous</em> <strong>iris</strong> dataset, which is included with the base version of R.</p>
<p>From <strong>Wikipedia</strong>: <em>The data set consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters. Based on the combination of these four features, Fisher developed a linear discriminant model to distinguish the species from each other.</em></p>
<pre class="r"><code>data(iris)
summary(iris)</code></pre>
<pre><code>##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  
##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  
##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  
##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  
##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  
##        Species  
##  setosa    :50  
##  versicolor:50  
##  virginica :50  
##                 
##                 
## </code></pre>
<div id="box-plots" class="section level3">
<h3>Box plots</h3>
<p>First, let’s create a simple simple box plot that displays <code>Petal.Width</code> differences by species. This is how we do it:</p>
<pre class="r"><code>iris1 &lt;- ggplot(iris, aes(x = Species, y = Petal.Width)) + 
  geom_boxplot()

iris1</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>This is a simple yet already very effective way to display the distribution, median values and inter quartile information of <code>Petal.Width</code> values across species, but we can do better. First of all, let’s add some extra information, such as a title and axis labels.</p>
<pre class="r"><code>iris2 &lt;- ggplot(iris, aes(x = Species, y = Petal.Width)) + 
  geom_boxplot() + ggtitle(&quot;Petal width differences by species&quot;) +
  xlab(&quot;Species&quot;) + ylab(&quot;Petal Width&quot;) + 
  theme_minimal()

iris2</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>From here, there’s a simple way we can improve upon this. While box plots are great at telling us the overall distribution and range of the data, they do not clearly convey the number of observations. We can remediate that by adding <code>geom_jitter()</code> to our plot. Each <em>jittery</em> point will corresponde to one observation.</p>
<pre class="r"><code>iris3 &lt;- ggplot(iris, aes(x = Species, y = Petal.Width)) + 
  geom_boxplot() + ggtitle(&quot;Petal width differences by species&quot;) +
  geom_jitter() +
  xlab(&quot;Species&quot;) + ylab(&quot;Petal Width&quot;) + 
  theme_minimal()

iris3</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Flower species are not a very linguistically-relevant subject, but the <strong>iris</strong> dataset is a very neat dataset. You could pretend that, instead of <code>Pedal.Width</code>, we are measuring <code>Normalised.f0</code> or <code>Vowel.Duration</code> across three different vowels, <code>a</code>, <code>e</code> and <code>i</code>. You would be using the same type of visualisation.</p>
<p>Eventually, someone looked at this and asked _"Could this be any better?__ and the answer is</p>
</div>
<div id="violin-plots" class="section level3">
<h3>Violin plots</h3>
<p>Violin plots are just like box plots, but instead of having a square box showing you the two inner quarters of the data, they are characterised by a shape representing the distribution of the observations.</p>
<pre class="r"><code>iris4 &lt;- ggplot(iris, aes(x = Species, y = Petal.Width)) + 
  geom_violin() + ggtitle(&quot;Petal width differences by species&quot;) +
  geom_jitter() +
  xlab(&quot;Species&quot;) + ylab(&quot;Petal Width&quot;) + 
  theme_minimal()

iris4</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Neat, heh? By the way, the <code>geom_jitter()</code> dots’ vertical placement depends on the observation’s value for whatever feature we are measuring on the Y axis. However, the horizontal placement of the dot (i.e. whether the jitter dot is on the left or the right side of the box or the violin) is random. The points are <em>jittered</em> horizontally so that they don’t all overlap. Similarly, the distribution shown by the violin is mirrored on the left and right side.</p>
<p>Why not add some colour too? It’s not really necessary here but..</p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>A very robust way of visualising data similar to a violin plot but, somehow, even more informative have been named <strong>Raincloud Plots</strong>. If you are interested, you can read more as well as find the full coding tutorial by <strong>Allen et al.</strong> to <em>make it rain</em> <a href="https://wellcomeopenresearch.org/articles/4-63">here</a>.</p>
</div>
<div id="extras" class="section level3">
<h3>Extras</h3>
<p>As an extra, we could add <code>colour</code> to <code>geom_jitter()</code> to provide information in regards to a different variable, such as <code>Petal.Length</code>. Let’s try that.</p>
<pre class="r"><code>#install.packages(&quot;viridis&quot;)
library(viridis)</code></pre>
<pre><code>## Loading required package: viridisLite</code></pre>
<pre class="r"><code>irisPW2 &lt;- ggplot(iris, aes(x = Species, y = Petal.Width, 
                          fill = Species)) + 
  geom_violin() + ggtitle(&quot;Petal width differences by species&quot;) +
  geom_jitter(data = iris, aes(colour = Petal.Length)) +
  xlab(&quot;Species&quot;) + ylab(&quot;Petal Width&quot;) + 
  scale_colour_viridis(option = &quot;magma&quot;) +
  scale_fill_manual(values = iris_col) +
  theme_minimal()

irisPW2</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
</div>
<div id="combining-multiple-ggplots" class="section level3">
<h3>Combining multiple ggplots</h3>
<p>One thiing that we can do now is to combine multiple different plots together with <code>ggarrange()</code>. Before, we combined plots together with <code>facet_wrap()</code> but, to do so, you can only combine together plots that share the same <code>aes()</code> values, such as the <code>x</code> and <code>y</code> values. However, with <code>ggarrange()</code> you can conbine together multiple <code>ggplot</code> objects, whatever they are.</p>
<p>Let’s make a quick scatterplot to investigate the correlation between <code>Petal.Width</code> and and <code>Petal.Length</code> by <code>Species</code>.</p>
<pre class="r"><code>irisPWPL &lt;- ggplot(iris, aes(x = Petal.Length, y = Petal.Width,
                              colour = Species)) + 
  geom_point(size = 4, pch = iris$Species) +
  xlab(&quot;Petal Length&quot;) + ylab(&quot;Petal Width&quot;) +
  ggtitle(&quot;Petal Length by Petal Width for three iris species&quot;) +
  scale_colour_manual(values = iris_col) +
  theme_minimal()

irisPWPL</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>In this particular case, combining the box plot and the scatter plot does not particularly add much value, as most of the information conveyed by the box plot is also conveyed by the scatter plot. However, we will do it as a form of exercise in coding. In order to combine the two plots together, all we need to do is to load the <code>ggpubr</code> library and call the <code>ggarrange()</code> function. You can explore all of the possibilities of <code>ggarrange()</code> by running the command <code>?ggarrange()</code>.</p>
<pre class="r"><code>#install.packages(&quot;ggpubr&quot;)
library(ggpubr)
ggarrange(irisPW, irisPWPL, common.legend = TRUE)</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
</div>
</div>
<div id="scatterplots" class="section level2">
<h2>Scatterplots</h2>
<p>We already saw one example of scatter plot earlier with the <code>irisPWPL</code> object. Now, we will be focusssing on a specific subset of scatter plots, often called <strong>vowel formant plots</strong>. Not everyone in linguistics works with vowel data, but vowel formant data is common enough that teaching how to visualise it <em>should</em> eventually become useful. At the very least, it will work as a prime example of how customisable <code>ggplot</code> objects are. In order to create vowel formant plots, we need vowels.</p>
<p>Let’s read in the <code>vowels.csv</code> file provided to you for this workshop. The dataset contains vowel measurements for a few participants, including <code>F1</code>, <code>F2</code>, <code>F3</code> and <code>F4</code> measurements in English. Each formant has been measured, for each observation, at 10 equal points across the vowel, for the realisation of vowel formant contours. We are interested in one measurements per formant per vowel, so we will only take measurements taken at the mid-point of each observation. We do so with the <code>filter()</code> function.</p>
<pre class="r"><code>vowels &lt;- read_csv(&quot;./vowels.csv&quot;) %&gt;% 
  filter(Timeinterval == 50)</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   Word = col_character(),
##   Vowel = col_character(),
##   Timeinterval = col_double(),
##   F1 = col_double(),
##   F2 = col_double(),
##   F3 = col_double(),
##   F4 = col_double(),
##   Speaker = col_double(),
##   Language = col_character()
## )</code></pre>
<pre class="r"><code>vowels$Speaker &lt;- as.factor(vowels$Speaker)

vowelz &lt;- vowels</code></pre>
<p>We do not have a lot of information in regards to the speakers. We do not know whether the gender of all the speakers is the same. We might want to normalise the formant measurements by speaker before we proceed with plotting. You can run the next code chunk to normalise the formant values.</p>
<pre class="r"><code>vowels &lt;- vowels %&gt;% group_by(Speaker) %&gt;%
  mutate(F1 = scale(F1)) %&gt;%
  mutate(F2 = scale(F2)) %&gt;%
  mutate(F3 = scale(F3)) %&gt;%
  mutate(F4 = scale(F4)) %&gt;%
  ungroup()</code></pre>
<p>Now, we can plot the normalised (scaled) F1-F2 data in a scatter plot. Here is what the most basic version of a formant plot would look like.</p>
<pre class="r"><code>vowels1 &lt;- ggplot(vowels, aes(x = F2, y = F1, 
                              colour = Vowel, pch = Speaker)) +
  geom_point(size = 2) + 
  xlab(&quot;F2&quot;) + ylab(&quot;F1&quot;)

vowels1</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>However, we know that most vowel plots are characterised by inverted axes, with F2 values often greater on the left side of the plot (towards the front of the mouth) and F1 values being greater towards the bottom of the plot (when the mouth is more open). <code>ggplot()</code> allows us to easily flip the axes and the axes labels.</p>
<pre class="r"><code>vowels2 &lt;- ggplot(vowels, aes(x = F2, y = F1, 
                              pch = Speaker, 
                              colour = Vowel)) +
  geom_point(size = 2) + 
  xlab(&quot;F2&quot;) + ylab(&quot;F1&quot;) +
  scale_x_reverse(lim = c(2, -2), position = &quot;top&quot;) +
  scale_y_reverse(lim = c(2, -2), position = &quot;right&quot;) +
  ggtitle(&quot;Normalised F1-F2 vowel charts for 5 speakers of English&quot;) +
  scale_color_viridis_d() +
  theme_minimal() 

vowels2</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<p>Here you go. The above is a classic F1-F2 vowel chart with normalised F1-F2 values in this case. Not the prettiest, but the aim here was to get a basic example that you can improve upon with the tools you have acquired through this brief workshop. Want to see something funky?</p>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p>Now we can compare the scaled data to the original data, to see the effects of normalisation on vowel formant data.</p>
<pre class="r"><code>vowels3 &lt;- ggplot(vowelz, aes(x = F2, y = F1, 
                              fill = Vowel)) +
  geom_encircle(alpha = 0.5) +
  geom_point(size = 2) + 
  xlab(&quot;F2&quot;) + ylab(&quot;F1&quot;) +
  scale_x_reverse(position = &quot;top&quot;) +
  scale_y_reverse(position = &quot;right&quot;) +
  scale_fill_viridis_d() +
  #ggtitle(&quot;Normalised F1-F2 vowel charts for 5 speakers of English&quot;) + 
  theme_minimal()

ggarrange(vowels2, vowels3, common.legend = TRUE)</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-34-1.png" width="672" />
# Homework</p>
<ul>
<li>What do you think is the best way to visually compare <code>"F1"</code> values only for all vowels across speakers?</li>
<li>How would you plot <code>"F2"</code> vowel contours (with ten measurements per vowel) for the diphtong <code>"ai"</code> for all <code>Speaker</code>s? (Hint: the <code>Timeinterval</code> variable reminds me of <code>time</code> in the <code>ERP</code> dataset..)</li>
<li>How would you compare <code>F1</code> and <code>F2</code> values of diphtongs at 20% and 80% of the diphtong trajectory?</li>
</ul>
<p>…</p>
<p>…</p>
<p>…</p>
</div>
</div>
<div id="solutions" class="section level1">
<h1>Solutions</h1>
<div id="task-1" class="section level2">
<h2>Task 1</h2>
<pre class="r"><code>vowels &lt;- read_csv(&quot;./vowels.csv&quot;) %&gt;% 
  filter(Timeinterval == 50)</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   Word = col_character(),
##   Vowel = col_character(),
##   Timeinterval = col_double(),
##   F1 = col_double(),
##   F2 = col_double(),
##   F3 = col_double(),
##   F4 = col_double(),
##   Speaker = col_double(),
##   Language = col_character()
## )</code></pre>
<pre class="r"><code>vowels$Speaker &lt;- as.factor(vowels$Speaker)</code></pre>
<pre class="r"><code>task1 &lt;- ggplot(vowels, aes(x = Vowel, y = F1, fill = Vowel)) +
  geom_violin(alpha = 0.8) + 
  geom_jitter() + 
  scale_fill_viridis_d() +
  ggtitle(&quot;F1 values for all speakers 
          and vowels, measured at the midpoint&quot;) +
  theme_minimal()

task1</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
</div>
<div id="task-2" class="section level2">
<h2>Task 2</h2>
<pre class="r"><code>vowelz &lt;- read_csv(&quot;./vowels.csv&quot;) %&gt;% 
  filter(Vowel == &quot;ai&quot; | Vowel == &quot;ei&quot; | Vowel == &quot;ou&quot;)</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   Word = col_character(),
##   Vowel = col_character(),
##   Timeinterval = col_double(),
##   F1 = col_double(),
##   F2 = col_double(),
##   F3 = col_double(),
##   F4 = col_double(),
##   Speaker = col_double(),
##   Language = col_character()
## )</code></pre>
<pre class="r"><code>vowelz$Speaker &lt;- as.factor(vowelz$Speaker)</code></pre>
<pre class="r"><code>task2 &lt;- ggplot(vowelz, aes(x = Timeinterval, y = F2, 
                            colour = Speaker)) +
  geom_point(size = 1, alpha = 0.8) + 
  facet_wrap(vars(Vowel)) + 
  xlab(&quot;Time Interval (in %)&quot;) +
  scale_colour_viridis_d() +
  theme_minimal() + 
  ggtitle(&quot;F2 diphtong contours for 5 English speakers and 3 vowels&quot;)

task2</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
</div>
<div id="task-3" class="section level2">
<h2>Task 3</h2>
<pre class="r"><code>vowel20 &lt;- filter(vowelz, Timeinterval == 20)
vowel80 &lt;- filter(vowelz, Timeinterval == 80)</code></pre>
<pre class="r"><code>library(ggforce)
library(ggalt)

F1F2plot &lt;- function(ds) {
  
  plot &lt;- ggplot(ds, aes(x = F2, y = F1, 
                              fill = Vowel)) +
  geom_encircle(alpha = 0.5) +
  geom_point(size = 2) + 
  xlab(&quot;F2&quot;) + ylab(&quot;F1&quot;) +
  scale_x_reverse(position = &quot;top&quot;) +
  scale_y_reverse(position = &quot;right&quot;) +
  scale_fill_viridis_d() +
  theme_minimal()
  
  return(plot) }</code></pre>
<pre class="r"><code>ggarrange(nrow = 2, F1F2plot(vowel20), F1F2plot(vowel80))</code></pre>
<p><img src="/posts/ii/ggplot_files/figure-html/unnamed-chunk-41-1.png" width="672" /></p>
</div>
</div>
